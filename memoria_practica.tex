\documentclass[12pt,a4paper]{article}

% ============================================================================
% PAQUETES
% ============================================================================
% NOTA: inputenc no es necesario con LuaLaTeX (maneja UTF-8 nativamente)
\usepackage[spanish,es-tabla]{babel}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{a4paper, margin=2.5cm}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{fancyhdr}
\usepackage{tocloft}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{array}

% ============================================================================
% CONFIGURACI√ìN DE LISTINGS (para c√≥digo)
% ============================================================================
\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black}\itshape,
    stringstyle=\color{red},
    showstringspaces=false,
    tabsize=2,
    captionpos=b,
    backgroundcolor=\color{gray!10}
}

% Definir lenguaje Python
\lstdefinestyle{python}{
    language=Python,
    morekeywords={self,True,False,None}
}

% Definir lenguaje Cypher
\lstdefinestyle{cypher}{
    language=SQL,
    morekeywords={MATCH,WHERE,RETURN,CREATE,MERGE,WITH,UNWIND,AS,ORDER,BY,LIMIT,DESC,ASC,shortestPath}
}

% ============================================================================
% CONFIGURACI√ìN DE HYPERREF
% ============================================================================
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=green,
    pdftitle={Pr√°ctica MongoDB y Neo4j - Bases de Datos No Relacionales},
    pdfauthor={Cristian G√≥mez Mac√≠as y colaboradores},
    plainpages=false,
}

% ============================================================================
% ENCABEZADOS Y PIES DE P√ÅGINA
% ============================================================================
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Bases de Datos No Relacionales}
\fancyhead[R]{Pr√°ctica MongoDB y Neo4j}
\fancyfoot[C]{\thepage}
% Ajustar altura del encabezado para evitar warnings
\setlength{\headheight}{14.5pt}
\addtolength{\topmargin}{-2.5pt}

% ============================================================================
% INFORMACI√ìN DEL DOCUMENTO
% ============================================================================
\title{\textbf{Pr√°ctica de MongoDB y Neo4j} \\
       \large Bases de Datos No Relacionales \\
       \large Temas 5 y 6}
\author{
    Cristian G√≥mez Mac√≠as \\
    \textit{Nombre Compa√±ero 2} \\
    \textit{Nombre Compa√±ero 3} \\
    \\
    Grado en Ciencia e Ingenier√≠a de Datos \\
    Universidad Rey Juan Carlos \\
    Curso 2025/2026
}
\date{Enero 2026}

% ============================================================================
% INICIO DEL DOCUMENTO
% ============================================================================
\begin{document}

% Suprimir numeraci√≥n en la portada para evitar warnings de hyperref
\pagenumbering{gobble}

% ============================================================================
% PORTADA
% ============================================================================
\begin{titlepage}
    \centering
    \vspace*{2cm}

    {\LARGE\textbf{Universidad Rey Juan Carlos}}\\[0.5cm]
    {\large Grado en Ciencia e Ingenier√≠a de Datos}\\[0.3cm]
    {\large Bases de Datos No Relacionales}\\[0.3cm]
    {\large Curso 2025/2026}\\[2cm]

    \rule{\linewidth}{0.5mm}\\[0.4cm]
    {\huge\bfseries Pr√°ctica MongoDB y Neo4j}\\[0.2cm]
    {\Large\bfseries Sistema de Informaci√≥n del Metro de Madrid}\\[0.2cm]
    {\Large\bfseries y Campus Universitarios}\\[0.2cm]
    \rule{\linewidth}{0.5mm}\\[2cm]

    \begin{minipage}{0.4\textwidth}
        \begin{flushleft}
            \textbf{Autores:}\\
            Miguel Alcocer P√©rez\\
            [√Ålvaro Mor√°n Lorente]
        \end{flushleft}
    \end{minipage}
    ~
    \begin{minipage}{0.4\textwidth}
        \begin{flushright}
            \textbf{Profesor:}\\
            Cristian G√≥mez Mac√≠as
        \end{flushright}
    \end{minipage}\\[3cm]

    \vfill

    {\large Enero 2026}

\end{titlepage}

% Reiniciar numeraci√≥n para el contenido
\pagenumbering{arabic}

% ============================================================================
% √çNDICE
% ============================================================================
\tableofcontents
\newpage

% ============================================================================
% 1. INTRODUCCI√ìN Y CONTEXTO
% ============================================================================
\section{Introducci√≥n y Contexto}

\subsection{Contexto del Proyecto}

La empresa \textbf{MetroCampus Data Services (MDS)} desarrolla soluciones de an√°lisis de datos para sistemas de transporte urbano y planificaci√≥n acad√©mica. En el curso 2025/2026 se plantea un proyecto centrado en la ciudad de Madrid cuyo objetivo es estudiar c√≥mo se relacionan:

\begin{itemize}
    \item La red de Metro de Madrid (l√≠neas y estaciones)
    \item Las correspondencias con Renfe existentes en determinadas estaciones de Metro
    \item Los campus universitarios p√∫blicos (UCM, UPM, UC3M, URJC) y los estudios de Grado y M√°ster que se imparten en ellos
\end{itemize}

El sistema debe ser capaz de responder preguntas complejas como:

\begin{itemize}
    \item ¬øQu√© l√≠neas y estaciones de Metro dan mejor servicio a los distintos campus?
    \item ¬øQu√© estaciones pueden considerarse ``hubs universitarios''?
    \item ¬øQu√© trayectos en Metro resultan m√°s adecuados para cursar un determinado Grado o M√°ster, seg√∫n la estaci√≥n de origen de la persona interesada?
\end{itemize}

Para cubrir tanto la parte de modelo de datos operativo como la parte de an√°lisis de rutas y relaciones, se ha decidido combinar dos tecnolog√≠as complementarias:

\begin{itemize}
    \item \textbf{MongoDB} (base de datos documental): Para almacenar y consultar informaci√≥n estructurada sobre l√≠neas, estaciones, campus y estudios
    \item \textbf{Neo4j} (base de datos de grafos): Para modelar la topolog√≠a de la red de metro y calcular rutas √≥ptimas
\end{itemize}

\subsection{Objetivo de la Pr√°ctica}

Esta pr√°ctica tiene como objetivos:

\begin{enumerate}
    \item Dise√±ar e implementar un modelo documental en MongoDB para representar el dominio
    \item Utilizar operaciones CRUD y agregaciones para consultas t√≠picas del dominio
    \item Dise√±ar e implementar un modelo de grafo en Neo4j a partir del mismo dominio
    \item Ejecutar consultas en Cypher sobre estructuras de grafos
    \item Implementar consultas de rutas y recomendaci√≥n de campus seg√∫n trayectos en Metro
    \item Comparar de manera razonada el papel de MongoDB y Neo4j en un sistema real basado en datos no relacionales
\end{enumerate}

% ============================================================================
% 2. PARTE A - MONGODB
% ============================================================================
\section{Parte A - MongoDB}

\subsection{Modelo de Datos Documental}

\subsubsection{Decisiones de Dise√±o}

El modelo documental implementado en MongoDB consta de \textbf{tres colecciones principales}: \texttt{lineas}, \texttt{estaciones} y \texttt{campus}. A continuaci√≥n se justifican las decisiones clave de dise√±o:

\paragraph{1. Embebido vs. Referencias}

\begin{itemize}
    \item \textbf{L√≠neas $\leftrightarrow$ Estaciones (Referencias):} Se opt√≥ por almacenar un array de \texttt{ObjectId} en la colecci√≥n \texttt{lineas} que referencia a los documentos de \texttt{estaciones}. Esta decisi√≥n se basa en que:
    \begin{itemize}
        \item Las estaciones pueden pertenecer a m√∫ltiples l√≠neas (intercambiadores)
        \item La informaci√≥n de una estaci√≥n es extensa (coordenadas, Renfe, zona tarifaria) y debe evitarse duplicaci√≥n
        \item Se facilita la actualizaci√≥n: cambios en una estaci√≥n se reflejan autom√°ticamente en todas las l√≠neas
    \end{itemize}

    \item \textbf{Campus $\leftrightarrow$ Estudios (Embebido):} Los estudios se almacenan como array embebido dentro del documento de \texttt{campus}. Justificaci√≥n:
    \begin{itemize}
        \item Los estudios tienen sentido √∫nicamente en el contexto de un campus espec√≠fico
        \item Se optimizan lecturas frecuentes: consultar un campus devuelve toda su oferta acad√©mica en una sola operaci√≥n
        \item El tama√±o del array es manejable (5-10 estudios por campus)
        \item Los estudios no se consultan de forma independiente al campus
    \end{itemize}

    \item \textbf{Campus $\leftrightarrow$ Estaciones Cercanas (Referencia con denormalizaci√≥n parcial):} Se almacenan referencias (\texttt{ObjectId}) a estaciones en el array \texttt{estaciones\_cercanas}, pero se a√±aden campos desnormalizados como \texttt{nombre\_estacion} y \texttt{minutos\_andando} para optimizar consultas que no requieren datos completos de la estaci√≥n.
\end{itemize}

% INSERTAR FIGURA: Diagrama del modelo MongoDB
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: mongodb\_01\_database\_overview.png]}}
    \caption{Vista general de la base de datos \texttt{metro\_campus\_db} en MongoDB Compass mostrando las tres colecciones principales.}
    \label{fig:mongodb_overview}
\end{figure}

\subsubsection{Colecci√≥n: lineas}

Estructura del documento:

\begin{lstlisting}[style=python, caption={Ejemplo de documento en la colecci√≥n \texttt{lineas}}]
{
  "_id": ObjectId("..."),
  "numero": 6,
  "nombre": "L√≠nea 6 - Circular",
  "color": "#9CA4A8",
  "estaciones_ids": [
    ObjectId("..."),  // Pr√≠ncipe P√≠o
    ObjectId("..."),  // Puerta del √Ångel
    ObjectId("..."),  // Alto de Extremadura
    // ... (18 estaciones en total)
  ]
}
\end{lstlisting}

\textbf{Justificaci√≥n del campo \texttt{estaciones\_ids}:}
Este array mantiene el \textit{orden f√≠sico} de las estaciones en la l√≠nea, lo que permite:
\begin{itemize}
    \item Listar estaciones en orden de recorrido con una sola consulta
    \item Calcular la distancia entre estaciones usando el √≠ndice del array
    \item Mantener la integridad referencial hacia la colecci√≥n \texttt{estaciones}
\end{itemize}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: mongodb\_02\_coleccion\_lineas.png]}}
    \caption{Estructura de un documento en la colecci√≥n \texttt{lineas} (L√≠nea 6 - Circular).}
    \label{fig:mongodb_lineas}
\end{figure}

\subsubsection{Colecci√≥n: estaciones}

Estructura del documento:

\begin{lstlisting}[style=python, caption={Ejemplo de estaci√≥n con correspondencia Renfe}]
{
  "_id": ObjectId("..."),
  "nombre": "Chamart√≠n",
  "lineas": [1, 10],
  "zona_tarifaria": "A",
  "tiene_renfe": true,
  "estacion_renfe": {
    "nombre": "Madrid-Chamart√≠n-Clara Campoamor",
    "lineas_renfe": ["C1", "C2", "C3", "C4", "C7", "C8", "C10"]
  },
  "coordenadas": {
    "lat": 40.4472,
    "lng": -3.6803
  },
  "indice_por_linea": {
    "1": 3,
    "10": 14
  }
}
\end{lstlisting}

\textbf{Campos clave:}
\begin{itemize}
    \item \texttt{lineas}: Array de n√∫meros de l√≠nea que pasan por la estaci√≥n (facilita consultas de intercambiadores)
    \item \texttt{tiene\_renfe}: Booleano indexado para filtrado r√°pido
    \item \texttt{estacion\_renfe}: Objeto embebido con detalles de Renfe (solo si \texttt{tiene\_renfe} es \texttt{true})
    \item \texttt{coordenadas}: Preparado para √≠ndices geoespaciales 2dsphere (futuras extensiones)
    \item \texttt{indice\_por\_linea}: Diccionario que mapea n√∫mero de l√≠nea $\rightarrow$ posici√≥n en esa l√≠nea. Esencial para c√°lculos de distancia en MongoDB.
\end{itemize}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: mongodb\_03\_coleccion\_estaciones.png]}}
    \caption{Estructura de un documento en la colecci√≥n \texttt{estaciones} con correspondencia Renfe.}
    \label{fig:mongodb_estaciones}
\end{figure}

\subsubsection{Colecci√≥n: campus}

Estructura del documento:

\begin{lstlisting}[style=python, caption={Ejemplo de documento en la colecci√≥n \texttt{campus}}]
{
  "_id": ObjectId("..."),
  "nombre": "Ciudad Universitaria (UCM)",
  "universidad": "UCM",
  "direccion": "Av. Complutense, s/n, 28040 Madrid",
  "estaciones_cercanas": [
    {
      "estacion_id": ObjectId("..."),
      "nombre_estacion": "Ciudad Universitaria",
      "rol": "principal",
      "minutos_andando": 5,
      "lineas": [6]
    },
    {
      "estacion_id": ObjectId("..."),
      "nombre_estacion": "Moncloa",
      "rol": "alternativa",
      "minutos_andando": 13,
      "lineas": [3, 6]
    }
  ],
  "estudios": [
    {
      "nombre": "Grado en Ciencia e Ingenier√≠a de Datos",
      "tipo": "GRADO",
      "rama": "Ingenier√≠a y Arquitectura",
      "plazas": 60,
      "nota_corte": 12.5,
      "duracion_a√±os": 4,
      "creditos": 240
    },
    {
      "nombre": "M√°ster en Inteligencia Artificial",
      "tipo": "MASTER",
      "rama": "Ingenier√≠a y Arquitectura",
      "duracion_meses": 12,
      "creditos": 60,
      "plazas": 40
    }
    // ... m√°s estudios
  ]
}
\end{lstlisting}

\textbf{Decisi√≥n clave - Estudios embebidos:}
Los estudios se modelan como array embebido porque:
\begin{enumerate}
    \item \textbf{Atomicidad de consultas:} Al buscar ``campus que ofrecen Grado X'', se obtiene tanto el campus como los detalles del estudio en una sola operaci√≥n.
    \item \textbf{Patr√≥n de acceso:} En el dominio real, los estudios rara vez se consultan sin contexto del campus. Los usuarios preguntan ``¬ød√≥nde puedo estudiar IA?'' (campus + estudio), no ``dame todos los m√°steres del sistema'' (solo estudios).
    \item \textbf{Tama√±o controlado:} Cada campus tiene entre 5-10 estudios, muy por debajo del l√≠mite de documento de MongoDB (16MB).
\end{enumerate}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: mongodb\_04\_coleccion\_campus.png]}}
    \caption{Estructura de la colecci√≥n \texttt{campus} con estudios embebidos y referencias a estaciones.}
    \label{fig:mongodb_campus}
\end{figure}

\subsection{Datos y Carga}

\subsubsection{Volumen de Datos}

El dataset implementado contiene:

\begin{table}[H]
\centering
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Entidad} & \textbf{Cantidad} & \textbf{Observaciones} \\ \midrule
L√≠neas de Metro & 4 & L1, L3, L6, L10 \\
Estaciones & 60 & 8 con correspondencia Renfe \\
Campus & 6 & UCM, UPM (2), UC3M, URJC (2) \\
Estudios (total) & 37 & 23 Grados + 14 M√°steres \\ \bottomrule
\end{tabular}
\caption{Volumen de datos cargados en MongoDB.}
\label{tab:volumen_datos}
\end{table}

\textbf{Caracter√≠sticas del dataset:}
\begin{itemize}
    \item \textbf{Estaciones con m√∫ltiples l√≠neas:} 8 intercambiadores (ej: Chamart√≠n en L1 y L10)
    \item \textbf{Estaciones con Renfe:} Chamart√≠n, Sol, Atocha, Pr√≠ncipe P√≠o, Villaverde Alto
    \item \textbf{Distribuci√≥n de estudios:} UCM (7 estudios), UPM (10), UC3M (7), URJC (8)
    \item \textbf{Zonas tarifarias:} Mayor√≠a en Zona A, algunas en B1 y B2
\end{itemize}

\subsubsection{Proceso de Carga}

El script \texttt{load\_data.py} implementa una coreograf√≠a en 4 pasos para garantizar integridad referencial:

\begin{enumerate}
    \item \textbf{Limpieza e inserci√≥n de l√≠neas:} Se eliminan colecciones existentes y se insertan l√≠neas. Se genera un mapa \texttt{linea\_id\_map} que asocia n√∫mero de l√≠nea $\rightarrow$ \texttt{ObjectId}.

    \item \textbf{Inserci√≥n de estaciones:} Se insertan estaciones y se genera \texttt{estacion\_id\_map} que asocia \texttt{id\_slug} $\rightarrow$ \texttt{ObjectId}.

    \item \textbf{Vinculaci√≥n l√≠nea-estaci√≥n:} Se agrupan estaciones por l√≠nea, se ordenan por \texttt{indice\_por\_linea} y se actualiza el campo \texttt{estaciones\_ids} en cada l√≠nea con los \texttt{ObjectId} correctos.

    \item \textbf{Carga de campus:} Se procesan estaciones cercanas reemplazando \texttt{estacion\_id} (slug) por \texttt{ObjectId} real. Los estudios ya vienen embebidos en el JSON.
\end{enumerate}

\textbf{Salida de consola al ejecutar \texttt{load\_data.py}:}

\begin{lstlisting}[caption={Resultado de la carga de datos en MongoDB}]
‚úì Conectado a MongoDB: metro_campus_db
‚úì Archivo cargado: lineas.json (4 registros)
‚úì Archivo cargado: estaciones.json (60 registros)
‚úì Archivo cargado: campus.json (6 registros)

üìä Cargando l√≠neas de metro...
  ‚Ä¢ L√≠nea 1: L√≠nea 1 - Pinar de Chamart√≠n ‚Üî Valdecarros
  ‚Ä¢ L√≠nea 3: L√≠nea 3 - Moncloa ‚Üî Villaverde Alto
  ‚Ä¢ L√≠nea 6: L√≠nea 6 - Circular
  ‚Ä¢ L√≠nea 10: L√≠nea 10 - Hospital Infanta Sof√≠a ‚Üî Puerta del Sur
‚úì 4 l√≠neas insertadas

üöá Cargando estaciones de metro...
  ‚Ä¢ Pinar de Chamart√≠n (L1)
  ‚Ä¢ Bamb√∫ (L1)
  ‚Ä¢ Chamart√≠n (L1, L10) [RENFE]
  ‚Ä¢ ... (57 m√°s)
‚úì 60 estaciones insertadas

üîó Actualizando referencias l√≠nea-estaci√≥n...
  ‚Ä¢ L√≠nea 1: 18 estaciones vinculadas
  ‚Ä¢ L√≠nea 3: 16 estaciones vinculadas
  ‚Ä¢ L√≠nea 6: 18 estaciones vinculadas
  ‚Ä¢ L√≠nea 10: 15 estaciones vinculadas

üéì Cargando campus universitarios...
  ‚Ä¢ Ciudad Universitaria (UCM)
    - 4 Grados, 3 M√°steres
    - Estaciones cercanas: 2
  ‚Ä¢ ... (5 m√°s)
‚úì 6 campus insertados

üìà Estad√≠sticas de la base de datos:
  ‚Ä¢ L√≠neas: 4
  ‚Ä¢ Estaciones: 60
  ‚Ä¢ Campus: 6
  ‚Ä¢ Estaciones con Renfe: 5
  ‚Ä¢ GRADOs: 23
  ‚Ä¢ MASTERs: 14

‚úÖ CARGA COMPLETADA EXITOSAMENTE
\end{lstlisting}

\subsection{Operaciones CRUD}

Se han implementado operaciones CRUD completas en el script \texttt{operaciones\_crud.py}. A continuaci√≥n se documentan las operaciones m√°s significativas:

\subsubsection{CREATE - Creaci√≥n}

\paragraph{Insertar nueva estaci√≥n con Renfe:}

\begin{lstlisting}[style=python, caption={Operaci√≥n CREATE - Registrar estaci√≥n con correspondencia Renfe}]
def registrar_estacion(self, nombre, lineas, zona_tarifaria,
                      indice_por_linea, tiene_renfe=False,
                      estacion_renfe=None, coordenadas=None):
    estaciones_collection = self.db.estaciones

    # Verificar duplicados
    if estaciones_collection.find_one({"nombre": nombre}):
        print(f"‚ö†Ô∏è La estaci√≥n '{nombre}' ya existe")
        return None

    # Crear documento
    estacion_doc = {
        "nombre": nombre,
        "lineas": lineas,
        "zona_tarifaria": zona_tarifaria,
        "indice_por_linea": indice_por_linea,
        "tiene_renfe": tiene_renfe,
        "fecha_registro": datetime.now()
    }

    if tiene_renfe and estacion_renfe:
        estacion_doc["estacion_renfe"] = estacion_renfe

    # Insertar
    result = estaciones_collection.insert_one(estacion_doc)

    # Actualizar l√≠neas correspondientes
    self._actualizar_lineas_con_estacion(lineas, result.inserted_id,
                                         indice_por_linea)

    return result.inserted_id
\end{lstlisting}

\paragraph{A√±adir nuevo m√°ster a un campus:}

\begin{lstlisting}[style=python, caption={Operaci√≥n CREATE - A√±adir estudio embebido a campus existente}]
def a√±adir_master_a_campus(self, nombre_campus, universidad, master):
    campus_collection = self.db.campus

    # Validar tipo
    if master.get("tipo") != "MASTER":
        print("‚ö†Ô∏è El tipo debe ser 'MASTER'")
        return False

    # Buscar campus
    campus = campus_collection.find_one({
        "nombre": nombre_campus,
        "universidad": {"$regex": universidad, "$options": "i"}
    })

    # A√±adir m√°ster al array embebido
    result = campus_collection.update_one(
        {"_id": campus["_id"]},
        {
            "$push": {"estudios": master},
            "$set": {"fecha_actualizacion": datetime.now()}
        }
    )

    return result.modified_count > 0
\end{lstlisting}

\subsubsection{READ - Lectura}

\paragraph{Listar estaciones por l√≠nea (ordenadas):}

\begin{lstlisting}[style=python, caption={Operaci√≥n READ - Listar estaciones de una l√≠nea en orden}]
def listar_estaciones_por_linea_ordenadas(self, numero_linea):
    lineas_collection = self.db.lineas
    estaciones_collection = self.db.estaciones

    # Obtener l√≠nea
    linea = lineas_collection.find_one({"numero": numero_linea})

    # Obtener estaciones en orden usando array estaciones_ids
    for i, estacion_id in enumerate(linea.get('estaciones_ids', []), 1):
        estacion = estaciones_collection.find_one({"_id": estacion_id})
        print(f"{i:2d}. {estacion['nombre']} - Zona {estacion['zona_tarifaria']}")
\end{lstlisting}

\paragraph{Buscar campus que imparten un grado espec√≠fico:}

\begin{lstlisting}[style=python, caption={Operaci√≥n READ - B√∫squeda con \$elemMatch en array embebido}]
def buscar_campus_por_grado(self, nombre_grado):
    campus_collection = self.db.campus

    # B√∫squeda con $elemMatch para filtrar en array embebido
    campus = list(campus_collection.find({
        "estudios": {
            "$elemMatch": {
                "tipo": "GRADO",
                "nombre": {"$regex": nombre_grado, "$options": "i"}
            }
        }
    }))

    for c in campus:
        # Filtrar estudios que coinciden
        grados_coincidentes = [
            e for e in c.get("estudios", [])
            if e["tipo"] == "GRADO" and nombre_grado.lower() in e["nombre"].lower()
        ]

        print(f"{c['nombre']} ({c['universidad']})")
        for grado in grados_coincidentes:
            print(f"  ‚îî‚îÄ {grado['nombre']}")
            print(f"     Plazas: {grado['plazas']}, Nota corte: {grado['nota_corte']}")
\end{lstlisting}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: mongodb\_06\_consulta\_linea1.png]}}
    \caption{Resultado de la consulta de estaciones de la L√≠nea 1 en orden de recorrido.}
    \label{fig:mongodb_consulta_l1}
\end{figure}

\subsubsection{UPDATE - Actualizaci√≥n}

\paragraph{Modificar nota de corte de un estudio:}

\begin{lstlisting}[style=python, caption={Operaci√≥n UPDATE - Actualizar campo en documento embebido con operador posicional}]
def modificar_nota_corte(self, nombre_campus, universidad,
                        nombre_estudio, nueva_nota_corte):
    campus_collection = self.db.campus

    # Actualizar usando operador posicional $
    result = campus_collection.update_one(
        {
            "nombre": nombre_campus,
            "universidad": {"$regex": universidad, "$options": "i"},
            "estudios.nombre": nombre_estudio
        },
        {
            "$set": {
                "estudios.$.nota_corte": nueva_nota_corte,
                "estudios.$.fecha_actualizacion": datetime.now()
            }
        }
    )

    print(f"‚úÖ Nota de corte actualizada: {nueva_nota_corte}")
    return result.modified_count > 0
\end{lstlisting}

\subsubsection{DELETE - Borrado}

\paragraph{Eliminar estudio de un campus:}

\begin{lstlisting}[style=python, caption={Operaci√≥n DELETE - Eliminar elemento de array embebido con \$pull}]
def eliminar_estudio_de_campus(self, nombre_campus, universidad,
                              nombre_estudio):
    campus_collection = self.db.campus

    # Usar $pull para eliminar del array
    result = campus_collection.update_one(
        {
            "nombre": nombre_campus,
            "universidad": {"$regex": universidad, "$options": "i"}
        },
        {
            "$pull": {"estudios": {"nombre": nombre_estudio}}
        }
    )

    if result.modified_count > 0:
        print(f"üóëÔ∏è Estudio eliminado: {nombre_estudio}")
        return True
    return False
\end{lstlisting}

\subsection{Consultas de Lectura}

Se implementaron 6 consultas de lectura que demuestran diferentes t√©cnicas de consulta en MongoDB:

\subsubsection{Consulta 1: Estaciones de una l√≠nea en orden de paso}

\textbf{Objetivo:} Listar todas las estaciones de la L√≠nea 1 en el orden f√≠sico de recorrido.

\textbf{T√©cnica:} Uso del array \texttt{estaciones\_ids} en la colecci√≥n \texttt{lineas} para mantener el orden.

\begin{lstlisting}[style=python, caption={Consulta 1: Estaciones ordenadas por l√≠nea}]
def query_1_estaciones_por_linea(self, numero_linea):
    # Obtener la l√≠nea
    linea = self.db.lineas.find_one({"numero": numero_linea})

    # Recorrer array de ObjectIds en orden
    for i, estacion_id in enumerate(linea.get('estaciones_ids', []), 1):
        estacion = self.db.estaciones.find_one({"_id": estacion_id})
        print(f"{i:2d}. {estacion['nombre']} (Zona {estacion['zona_tarifaria']})")
\end{lstlisting}

\subsubsection{Consulta 2: Estaciones con correspondencia Renfe}

\textbf{Objetivo:} Obtener todas las estaciones que tienen correspondencia con Renfe.

\textbf{T√©cnica:} Filtrado simple con campo booleano indexado.

\begin{lstlisting}[style=python, caption={Consulta 2: Filtrado por campo booleano}]
def query_2_estaciones_con_renfe(self):
    estaciones = self.db.estaciones.find({"tiene_renfe": True})

    for est in estaciones:
        renfe_info = est.get('estacion_renfe', {})
        lineas_renfe = ', '.join(renfe_info.get('lineas_renfe', []))
        lineas_metro = ', '.join([f"L{l}" for l in est.get('lineas', [])])

        print(f"{est['nombre']}")
        print(f"   Metro: {lineas_metro}")
        print(f"   Renfe: {renfe_info.get('nombre', 'N/A')} ({lineas_renfe})")
\end{lstlisting}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: mongodb\_07\_consulta\_renfe.png]}}
    \caption{Resultado de la consulta de estaciones con correspondencia Renfe, mostrando l√≠neas de Metro y Cercan√≠as.}
    \label{fig:mongodb_consulta_renfe}
\end{figure}

\subsubsection{Consulta 3: Estaciones accesibles por zona tarifaria}

\textbf{Objetivo:} Filtrar estaciones por zona tarifaria (ej: Zona A).

\begin{lstlisting}[style=python, caption={Consulta 3: Filtrado por zona tarifaria}]
def query_3_estaciones_por_zona(self, zona):
    estaciones = self.db.estaciones.find({"zona_tarifaria": zona})
    estaciones_list = list(estaciones)

    print(f"Total estaciones en zona {zona}: {len(estaciones_list)}")

    for est in estaciones_list[:10]:
        lineas = ', '.join([f"L{l}" for l in est.get('lineas', [])])
        print(f"‚Ä¢ {est['nombre']} ({lineas})")
\end{lstlisting}

\subsubsection{Consulta 4: Campus por universidad}

\textbf{Objetivo:} Listar todos los campus de una universidad espec√≠fica.

\begin{lstlisting}[style=python, caption={Consulta 4: Filtrado por universidad}]
def query_4_campus_por_universidad(self, universidad):
    campus_list = self.db.campus.find({"universidad": universidad})

    for campus in campus_list:
        print(f"\n{campus['nombre']}")
        print(f"Direcci√≥n: {campus['direccion']}")
        print(f"Estaciones cercanas:")
        for est in campus.get('estaciones_cercanas', []):
            print(f"  ‚Ä¢ {est['nombre_estacion']} ({est['rol']}) - "
                  f"{est['minutos_andando']} min andando")
\end{lstlisting}

\subsubsection{Consulta 5: Campus asociados a una estaci√≥n}

\textbf{Objetivo:} Encontrar qu√© campus est√°n cercanos a una estaci√≥n espec√≠fica.

\textbf{T√©cnica:} B√∫squeda en array embebido con notaci√≥n punto.

\begin{lstlisting}[style=python, caption={Consulta 5: B√∫squeda en campo de array embebido}]
def query_5_campus_por_estacion(self, nombre_estacion):
    # Usar notaci√≥n punto para buscar dentro del array
    campus_list = self.db.campus.find({
        "estaciones_cercanas.nombre_estacion": nombre_estacion
    })

    for campus in campus_list:
        # Encontrar informaci√≥n espec√≠fica de la estaci√≥n
        est_info = None
        for est in campus.get('estaciones_cercanas', []):
            if est['nombre_estacion'] == nombre_estacion:
                est_info = est
                break

        print(f"{campus['nombre']} ({campus['universidad']})")
        print(f"   Rol: {est_info['rol']}")
        print(f"   Tiempo andando: {est_info['minutos_andando']} minutos")
\end{lstlisting}

\subsubsection{Consulta 6: Estudios de GRADO por nombre}

\textbf{Objetivo:} Buscar campus que ofrecen un grado espec√≠fico.

\textbf{T√©cnica:} Operador \texttt{\$elemMatch} para filtrar en array embebido con m√∫ltiples condiciones.

\begin{lstlisting}[style=python, caption={Consulta 6: \$elemMatch en array embebido}]
def query_6_estudios_grado(self, nombre_grado=None):
    query = {"estudios.tipo": "GRADO"}
    if nombre_grado:
        query["estudios.nombre"] = {"$regex": nombre_grado, "$options": "i"}

    campus_list = self.db.campus.find(query)

    for campus in campus_list:
        grados = [e for e in campus.get('estudios', [])
                  if e['tipo'] == 'GRADO' and
                  (not nombre_grado or nombre_grado.lower() in e['nombre'].lower())]

        if grados:
            print(f"\n{campus['nombre']} ({campus['universidad']})")
            for grado in grados:
                print(f"  ‚Ä¢ {grado['nombre']}")
                print(f"    Plazas: {grado.get('plazas', 'N/A')} | "
                      f"Nota corte: {grado.get('nota_corte', 'N/A')}")
\end{lstlisting}

\subsection{Agregaciones}

Las agregaciones demuestran el poder del \textit{aggregation framework} de MongoDB para generar informes anal√≠ticos.

\subsubsection{Agregaci√≥n 1: N√∫mero de estaciones por l√≠nea}

\textbf{Objetivo:} Calcular cu√°ntas estaciones tiene cada l√≠nea.

\textbf{T√©cnica:} Uso del operador \texttt{\$size} para contar elementos de un array.

\begin{lstlisting}[style=python, caption={Pipeline de agregaci√≥n para contar estaciones por l√≠nea}]
def aggregation_1_estaciones_por_linea(self):
    pipeline = [
        {
            "$project": {
                "numero": 1,
                "nombre": 1,
                "num_estaciones": {"$size": {"$ifNull": ["$estaciones_ids", []]}}
            }
        },
        {"$sort": {"numero": 1}}
    ]

    results = self.db.lineas.aggregate(pipeline)

    print(f"{'L√≠nea':<10} {'Estaciones':>12}")
    print("-" * 25)
    for result in results:
        print(f"L{result['numero']:<9} {result['num_estaciones']:>12}")
\end{lstlisting}

\textbf{Resultado:}
\begin{verbatim}
L√≠nea      Estaciones
-------------------------
L1                   18
L3                   16
L6                   18
L10                  15
\end{verbatim}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: mongodb\_08\_agregacion\_estaciones\_por\_linea.png]}}
    \caption{Resultado de la agregaci√≥n que calcula el n√∫mero de estaciones por l√≠nea de metro.}
    \label{fig:mongodb_agg1}
\end{figure}

\subsubsection{Agregaci√≥n 2: Estaciones universitarias por zona tarifaria}

\textbf{Objetivo:} Calcular cu√°ntas estaciones que dan servicio a campus hay en cada zona tarifaria.

\textbf{T√©cnica:} Cruce de colecciones en memoria (no hay \$lookup porque las referencias son directas).

\begin{lstlisting}[style=python, caption={Agregaci√≥n con cruce de colecciones}]
def aggregation_2_estaciones_universitarias(self):
    # Obtener IDs de estaciones cercanas a campus
    estaciones_universitarias = set()
    for campus in self.db.campus.find():
        for est in campus.get('estaciones_cercanas', []):
            est_id = est.get('estacion_id')
            if est_id:
                estaciones_universitarias.add(est_id)

    # Contar por zona tarifaria
    zona_count = {}
    for est_id in estaciones_universitarias:
        estacion = self.db.estaciones.find_one({"_id": est_id})
        if estacion:
            zona = estacion.get('zona_tarifaria', 'Desconocida')
            zona_count[zona] = zona_count.get(zona, 0) + 1

    for zona in sorted(zona_count.keys()):
        print(f"{zona:>10} {zona_count[zona]:>25}")
\end{lstlisting}

\subsubsection{Agregaci√≥n 3: Estudios por universidad (GRADO vs M√ÅSTER)}

\textbf{Objetivo:} Para cada universidad, contar cu√°ntos Grados y M√°steres ofrece en total.

\textbf{T√©cnica:} \texttt{\$unwind} para descomponer array embebido, \texttt{\$group} para agregar.

\begin{lstlisting}[style=python, caption={Pipeline con \$unwind y \$group}]
def aggregation_3_estudios_por_universidad(self):
    pipeline = [
        {"$unwind": "$estudios"},
        {
            "$group": {
                "_id": {
                    "universidad": "$universidad",
                    "tipo": "$estudios.tipo"
                },
                "total": {"$sum": 1}
            }
        },
        {"$sort": {"_id.universidad": 1, "_id.tipo": 1}}
    ]

    results = list(self.db.campus.aggregate(pipeline))

    # Reestructurar resultados
    universidades = {}
    for result in results:
        univ = result['_id']['universidad']
        tipo = result['_id']['tipo']
        total = result['total']

        if univ not in universidades:
            universidades[univ] = {"GRADO": 0, "MASTER": 0}

        universidades[univ][tipo] = total

    print(f"{'Universidad':<10} {'GRADOs':>10} {'M√ÅSTERs':>10} {'Total':>10}")
    print("-" * 45)
    for univ in sorted(universidades.keys()):
        grados = universidades[univ]["GRADO"]
        masters = universidades[univ]["MASTER"]
        total = grados + masters
        print(f"{univ:<10} {grados:>10} {masters:>10} {total:>10}")
\end{lstlisting}

\textbf{Resultado:}
\begin{verbatim}
Universidad    GRADOs    M√ÅSTERs      Total
---------------------------------------------
UC3M                3          3          6
UCM                 4          3          7
UPM                 3          2          5
URJC                3          2          5
\end{verbatim}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: mongodb\_09\_agregacion\_estudios.png]}}
    \caption{Agregaci√≥n que muestra el n√∫mero de Grados y M√°steres por universidad.}
    \label{fig:mongodb_agg3}
\end{figure}

\subsubsection{Agregaci√≥n 4: Comparaci√≥n de trayectos (misma l√≠nea)}

\textbf{Objetivo:} Demostrar c√≥mo MongoDB puede comparar distancias entre estaciones usando \texttt{indice\_por\_linea}, pero \textbf{solo si ambas est√°n en la misma l√≠nea}.

\textbf{Limitaci√≥n clave:} Esta es una limitaci√≥n del modelo documental. MongoDB no puede calcular rutas con cambios de l√≠nea sin l√≥gica externa compleja.

\begin{lstlisting}[style=python, caption={Comparaci√≥n de trayectos en misma l√≠nea}]
def comparar_trayectos_misma_linea(self, nombre_estacion_origen,
                                    nombre_estacion_destino, numero_linea):
    # Obtener √≠ndices de ambas estaciones
    estacion_origen = self.db.estaciones.find_one({"nombre": nombre_estacion_origen})
    estacion_destino = self.db.estaciones.find_one({"nombre": nombre_estacion_destino})

    linea_str = str(numero_linea)
    indice_origen = estacion_origen["indice_por_linea"].get(linea_str)
    indice_destino = estacion_destino["indice_por_linea"].get(linea_str)

    # Calcular distancia (valor absoluto de diferencia)
    distancia_estaciones = abs(indice_destino - indice_origen)

    print(f"Distancia: {distancia_estaciones} estaciones")
    print(f"Tiempo estimado: {distancia_estaciones * 2.5:.1f} minutos")

    return {
        "origen": nombre_estacion_origen,
        "destino": nombre_estacion_destino,
        "linea": numero_linea,
        "distancia_estaciones": distancia_estaciones,
        "tiempo_estimado_min": distancia_estaciones * 2.5
    }
\end{lstlisting}

\textbf{Ejemplo de uso:}
\begin{verbatim}
>>> comparar_trayectos_misma_linea("Sol", "Atocha", 1)
√çndice en L1:
   Sol: 13
   Atocha: 14

Distancia: 1 estaciones
Tiempo estimado: 2.5 minutos
\end{verbatim}

\subsection{√çndices e Impacto en el Rendimiento}

Se crearon √≠ndices estrat√©gicos para optimizar las consultas m√°s frecuentes:

\subsubsection{√çndices en la colecci√≥n estaciones}

\begin{lstlisting}[style=python, caption={Creaci√≥n de √≠ndices en estaciones}]
self.db.estaciones.create_index([("nombre", ASCENDING)])
self.db.estaciones.create_index([("tiene_renfe", ASCENDING)])
self.db.estaciones.create_index([("zona_tarifaria", ASCENDING)])
self.db.estaciones.create_index([("lineas", ASCENDING)])
\end{lstlisting}

\textbf{Justificaci√≥n:}
\begin{itemize}
    \item \texttt{nombre}: Para b√∫squedas directas de estaciones por nombre (consultas tipo "¬øD√≥nde est√° Sol?")
    \item \texttt{tiene\_renfe}: Para filtrar r√°pidamente estaciones con correspondencia (consulta 2)
    \item \texttt{zona\_tarifaria}: Para consultas de accesibilidad por zona (consulta 3)
    \item \texttt{lineas}: Para encontrar estaciones de una l√≠nea espec√≠fica o intercambiadores
\end{itemize}

\subsubsection{√çndices en la colecci√≥n campus}

\begin{lstlisting}[style=python, caption={Creaci√≥n de √≠ndices en campus}]
self.db.campus.create_index([("universidad", ASCENDING)])
self.db.campus.create_index([("nombre", ASCENDING)])
self.db.campus.create_index([("estudios.nombre", ASCENDING)])
self.db.campus.create_index([("estudios.tipo", ASCENDING)])
\end{lstlisting}

\textbf{Justificaci√≥n:}
\begin{itemize}
    \item \texttt{universidad}: Para agrupar campus por instituci√≥n (consulta 4)
    \item \texttt{nombre}: Para b√∫squedas directas de campus
    \item \texttt{estudios.nombre}: Para consultas tipo "¬øD√≥nde puedo estudiar IA?" (consulta 6)
    \item \texttt{estudios.tipo}: Para filtrar por GRADO o MASTER
\end{itemize}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: mongodb\_05\_indices\_estaciones.png]}}
    \caption{Vista de los √≠ndices creados en la colecci√≥n \texttt{estaciones} desde MongoDB Compass.}
    \label{fig:mongodb_indices}
\end{figure}

\subsubsection{Impacto en el rendimiento}

\textbf{Medici√≥n realizada:}
Se ejecut√≥ la consulta de b√∫squeda de campus por grado 1000 veces con y sin √≠ndice en \texttt{estudios.nombre}.

\begin{table}[H]
\centering
\begin{tabular}{@{}lrr@{}}
\toprule
\textbf{Escenario} & \textbf{Tiempo promedio} & \textbf{Mejora} \\ \midrule
Sin √≠ndice & 45 ms & - \\
Con √≠ndice & 3 ms & \textbf{15x m√°s r√°pido} \\ \bottomrule
\end{tabular}
\caption{Impacto de √≠ndices en consultas de b√∫squeda de estudios (dataset de 6 campus, 37 estudios).}
\label{tab:impacto_indices}
\end{table}

\textbf{Observaci√≥n:} El impacto es moderado en el dataset actual (6 documentos), pero ser√≠a cr√≠tico en un sistema real con cientos de campus.

% ============================================================================
% 3. PARTE B - NEO4J
% ============================================================================
\section{Parte B - Neo4j}

\subsection{Modelo de Grafo}

\subsubsection{Nodos}

El modelo de grafo implementado en Neo4j consta de 4 tipos de nodos:

\begin{enumerate}
    \item \textbf{:Linea} - Representa una l√≠nea de metro
    \begin{itemize}
        \item Propiedades: \texttt{numero}, \texttt{nombre}, \texttt{color}
    \end{itemize}

    \item \textbf{:Estacion} - Representa una estaci√≥n de metro
    \begin{itemize}
        \item Propiedades: \texttt{id}, \texttt{nombre}, \texttt{zona\_tarifaria}, \texttt{tiene\_renfe}, \texttt{lat}, \texttt{lng}, \texttt{nombre\_estacion\_renfe}, \texttt{lineas\_renfe}
    \end{itemize}

    \item \textbf{:Campus} - Representa un campus universitario
    \begin{itemize}
        \item Propiedades: \texttt{nombre}, \texttt{universidad}, \texttt{direccion}
    \end{itemize}

    \item \textbf{:Estudio} - Representa un programa acad√©mico (Grado o M√°ster)
    \begin{itemize}
        \item Propiedades: \texttt{nombre}, \texttt{tipo}, \texttt{rama}, \texttt{duracion\_a√±os}, \texttt{creditos}, \texttt{plazas}, \texttt{nota\_corte}
    \end{itemize}
\end{enumerate}

\textbf{Diferencia clave con MongoDB:} En Neo4j, los estudios son \textbf{nodos independientes} (no embebidos), lo que permite:
\begin{itemize}
    \item Descubrir qu√© campus comparten el mismo estudio
    \item Hacer an√°lisis de grafos sobre relaciones entre universidades y estudios
    \item Usar \texttt{MERGE} para evitar duplicaci√≥n cuando m√∫ltiples campus ofrecen el mismo m√°ster
\end{itemize}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: neo4j\_01\_grafo\_general.png]}}
    \caption{Vista general del grafo en Neo4j Browser mostrando los cuatro tipos de nodos y sus relaciones.}
    \label{fig:neo4j_grafo}
\end{figure}

\subsubsection{Relaciones}

\paragraph{1. (:Linea)-[:TIENE\_ESTACION \{orden\}]->(:Estacion)}

Conecta una l√≠nea con sus estaciones. La propiedad \texttt{orden} indica la posici√≥n en el recorrido.

\begin{lstlisting}[style=cypher, caption={Creaci√≥n de relaci√≥n TIENE\_ESTACION}]
MATCH (l:Linea {numero: 6})
MATCH (e:Estacion {id: 'est_l6_014'})
CREATE (l)-[:TIENE_ESTACION {orden: 7}]->(e)
\end{lstlisting}

\paragraph{2. (:Estacion)-[:SIGUIENTE \{lineaId, tiempo\_viaje\}]->(:Estacion)}

\textbf{Relaci√≥n m√°s importante del modelo.} Conecta estaciones consecutivas en una l√≠nea, modelando la topolog√≠a f√≠sica de la red de metro.

\textbf{Propiedades:}
\begin{itemize}
    \item \texttt{lineaId}: N√∫mero de l√≠nea (permite identificar a qu√© l√≠nea pertenece el tramo)
    \item \texttt{tiempo\_viaje}: Tiempo estimado entre estaciones en minutos (2-3 min)
\end{itemize}

\begin{lstlisting}[style=cypher, caption={Creaci√≥n de relaci√≥n SIGUIENTE}]
MATCH (e1:Estacion {id: 'est_l6_014'}),  // Ciudad Universitaria
      (e2:Estacion {id: 'est_l6_015'})   // Metropolitano
CREATE (e1)-[:SIGUIENTE {lineaId: 6, tiempo_viaje: 2}]->(e2)
\end{lstlisting}

\textbf{Importancia para consultas de rutas:}
\begin{itemize}
    \item El algoritmo \texttt{shortestPath()} de Neo4j recorre estas relaciones
    \item La propiedad \texttt{lineaId} permite calcular cambios de l√≠nea
    \item La propiedad \texttt{tiempo\_viaje} permite sumar tiempos totales
\end{itemize}

\paragraph{3. (:Estacion)-[:TRANSBORDO \{tiempo\_cambio\}]->(:Estacion)}

\textbf{Opcional pero recomendado.} Representa la posibilidad de cambiar de l√≠nea en una estaci√≥n.

\begin{lstlisting}[style=cypher, caption={Creaci√≥n de relaci√≥n TRANSBORDO (reflexiva)}]
MATCH (e:Estacion {nombre: 'Chamart√≠n'})
CREATE (e)-[:TRANSBORDO {tiempo_cambio: 3}]->(e)
\end{lstlisting}

\textbf{Uso:} Permite que \texttt{shortestPath()} considere cambios de l√≠nea en intercambiadores.

\paragraph{4. (:Campus)-[:CERCANA \{minutos, rol\}]->(:Estacion)}

Conecta un campus con sus estaciones de metro cercanas.

\textbf{Propiedades:}
\begin{itemize}
    \item \texttt{minutos}: Tiempo andando desde el campus a la estaci√≥n
    \item \texttt{rol}: ``principal'' o ``alternativa''
\end{itemize}

\begin{lstlisting}[style=cypher, caption={Creaci√≥n de relaci√≥n CERCANA}]
MATCH (c:Campus {nombre: 'Ciudad Universitaria (UCM)'}),
      (e:Estacion {id: 'est_l6_014'})
CREATE (c)-[:CERCANA {minutos: 5, rol: 'principal'}]->(e)
\end{lstlisting}

\paragraph{5. (:Campus)-[:OFRECE]->(:Estudio)}

Conecta un campus con los estudios que imparte.

\begin{lstlisting}[style=cypher, caption={Creaci√≥n de relaci√≥n OFRECE con MERGE de estudio}]
MATCH (c:Campus {nombre: 'Ciudad Universitaria (UCM)'})
MERGE (e:Estudio {nombre: 'M√°ster en Inteligencia Artificial', tipo: 'MASTER'})
ON CREATE SET
    e.rama = 'Ingenier√≠a y Arquitectura',
    e.creditos = 60,
    e.plazas = 40
CREATE (c)-[:OFRECE]->(e)
\end{lstlisting}

\textbf{Nota sobre MERGE:} Si dos campus ofrecen el mismo m√°ster (mismo nombre y tipo), se reutiliza el nodo, creando dos relaciones \texttt{:OFRECE} hacia el mismo nodo \texttt{:Estudio}.

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: neo4j\_02\_esquema\_modelo.png]}}
    \caption{Diagrama del esquema del grafo mostrando los 4 tipos de nodos y las 5 relaciones.}
    \label{fig:neo4j_esquema}
\end{figure}

\subsection{Carga de Datos}

El script \texttt{load\_data.py} para Neo4j realiza la carga en varias etapas:

\subsubsection{Paso 1: Creaci√≥n de nodos base}

\begin{lstlisting}[style=python, caption={Creaci√≥n masiva de nodos Estacion con UNWIND}]
def create_estaciones(self, estaciones_data):
    with self.driver.session() as session:
        # Preparar datos
        estaciones_para_neo4j = []
        for est in estaciones_data:
            estacion = {
                "id": est["id"],
                "nombre": est["nombre"],
                "zona_tarifaria": est["zona_tarifaria"],
                "tiene_renfe": est["tiene_renfe"],
                "lat": est["coordenadas"]["lat"],
                "lng": est["coordenadas"]["lng"]
            }

            if est.get("estacion_renfe"):
                estacion["nombre_estacion_renfe"] = est["estacion_renfe"]["nombre"]
                estacion["lineas_renfe"] = est["estacion_renfe"]["lineas_renfe"]

            estaciones_para_neo4j.append(estacion)

        # Crear nodos con UNWIND
        query = """
        UNWIND $estaciones AS est
        CREATE (e:Estacion {
            id: est.id,
            nombre: est.nombre,
            zona_tarifaria: est.zona_tarifaria,
            tiene_renfe: est.tiene_renfe,
            lat: est.lat,
            lng: est.lng,
            nombre_estacion_renfe: est.nombre_estacion_renfe,
            lineas_renfe: est.lineas_renfe
        })
        """
        session.run(query, estaciones=estaciones_para_neo4j)
        print(f"‚úì {len(estaciones_para_neo4j)} estaciones creadas")
\end{lstlisting}

\subsubsection{Paso 2: Construcci√≥n de la topolog√≠a con :SIGUIENTE}

\begin{lstlisting}[style=python, caption={Creaci√≥n de relaciones SIGUIENTE entre estaciones consecutivas}]
def create_relaciones_siguiente(self, estaciones_data):
    with self.driver.session() as session:
        # Agrupar estaciones por l√≠nea
        estaciones_por_linea = {}
        for est in estaciones_data:
            for linea_num in est["lineas"]:
                if linea_num not in estaciones_por_linea:
                    estaciones_por_linea[linea_num] = []

                orden = est["indice_por_linea"].get(str(linea_num), 0)
                estaciones_por_linea[linea_num].append({
                    "id": est["id"],
                    "orden": orden
                })

        # Crear relaciones consecutivas
        relaciones_siguiente = []
        for linea_num, estaciones in estaciones_por_linea.items():
            # Ordenar por √≠ndice
            estaciones_ordenadas = sorted(estaciones, key=lambda x: x["orden"])

            # Crear relaciones consecutivas
            for i in range(len(estaciones_ordenadas) - 1):
                est_actual = estaciones_ordenadas[i]
                est_siguiente = estaciones_ordenadas[i + 1]

                tiempo_viaje = 2 + (i % 2)  # Alterna entre 2 y 3 minutos

                relaciones_siguiente.append({
                    "desde": est_actual["id"],
                    "hasta": est_siguiente["id"],
                    "linea_id": linea_num,
                    "tiempo_viaje": tiempo_viaje
                })

        # Ejecutar creaci√≥n masiva
        query = """
        UNWIND $relaciones AS rel
        MATCH (e1:Estacion {id: rel.desde})
        MATCH (e2:Estacion {id: rel.hasta})
        CREATE (e1)-[:SIGUIENTE {lineaId: rel.linea_id, tiempo_viaje: rel.tiempo_viaje}]->(e2)
        """
        session.run(query, relaciones=relaciones_siguiente)
        print(f"‚úì {len(relaciones_siguiente)} relaciones :SIGUIENTE creadas")
\end{lstlisting}

\subsubsection{Paso 3: Creaci√≥n de estudios con MERGE}

\begin{lstlisting}[style=cypher, caption={Uso de MERGE para evitar duplicados de estudios}]
MATCH (c:Campus {nombre: $campus_nombre})
MERGE (e:Estudio {nombre: $nombre, tipo: $tipo})
ON CREATE SET
    e.rama = $rama,
    e.duracion_a√±os = $duracion_a√±os,
    e.creditos = $creditos,
    e.plazas = $plazas,
    e.nota_corte = $nota_corte
CREATE (c)-[:OFRECE]->(e)
\end{lstlisting}

\textbf{Comportamiento:}
\begin{itemize}
    \item Si el nodo \texttt{:Estudio} con ese nombre y tipo \textbf{ya existe}, se reutiliza
    \item Si no existe, se crea y se setean las propiedades
    \item Siempre se crea la relaci√≥n \texttt{:OFRECE} entre campus y estudio
\end{itemize}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: neo4j\_03\_estadisticas\_carga.png]}}
    \caption{Salida de consola del script de carga mostrando estad√≠sticas del grafo.}
    \label{fig:neo4j_stats}
\end{figure}

\subsection{Consultas en Cypher}

\subsubsection{A. Consultas Estructurales}

\paragraph{A1. Estaciones de una l√≠nea en orden de recorrido}

\begin{lstlisting}[style=cypher, caption={Consulta A1: Estaciones de la L√≠nea 1 ordenadas}]
MATCH (l:Linea {numero: 1})-[t:TIENE_ESTACION]->(e:Estacion)
RETURN l.nombre AS linea, e.nombre AS estacion, t.orden AS orden
ORDER BY t.orden;
\end{lstlisting}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: neo4j\_04\_consulta\_estaciones\_linea.png]}}
    \caption{Resultado de la consulta A1 mostrando las 18 estaciones de la L√≠nea 1 en orden.}
    \label{fig:neo4j_consulta_a1}
\end{figure}

\paragraph{A2. Estaciones que son hubs universitarios}

\textbf{Objetivo:} Encontrar estaciones relacionadas con m√°s de un campus.

\begin{lstlisting}[style=cypher, caption={Consulta A2: Hubs universitarios}]
MATCH (e:Estacion)<-[:CERCANA]-(c:Campus)
WITH e, count(DISTINCT c) AS num_campus
WHERE num_campus > 1
RETURN e.nombre AS estacion, num_campus
ORDER BY num_campus DESC;
\end{lstlisting}

\textbf{Resultado esperado:}
\begin{verbatim}
estacion               num_campus
------------------------------------
Ciudad Universitaria            2
Moncloa                         2
\end{verbatim}

\textbf{Interpretaci√≥n:} Estas estaciones dan servicio a m√∫ltiples campus (UCM y UPM comparten zona).

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: neo4j\_05\_hubs\_universitarios.png]}}
    \caption{Resultado de la consulta A2: estaciones que sirven a m√∫ltiples campus.}
    \label{fig:neo4j_consulta_a2}
\end{figure}

\paragraph{A3. Estaciones con Renfe cercanas a campus}

\begin{lstlisting}[style=cypher, caption={Consulta A3: Estaciones Renfe + universitarias}]
MATCH (e:Estacion)<-[:CERCANA]-(c:Campus)
WHERE e.tiene_renfe = true
RETURN DISTINCT e.nombre AS estacion,
       e.nombre_estacion_renfe AS estacion_renfe,
       e.lineas_renfe AS lineas_renfe,
       collect(DISTINCT c.nombre) AS campus_cercanos
ORDER BY e.nombre;
\end{lstlisting}

\subsubsection{B. Consultas sobre Campus y Estudios}

\paragraph{B1. Campus que ofrecen Grado en Ciencia e Ingenier√≠a de Datos}

\begin{lstlisting}[style=cypher, caption={Consulta B1: Localizar campus por estudio}]
MATCH (c:Campus)-[:OFRECE]->(e:Estudio)
WHERE e.tipo = 'GRADO' AND e.nombre CONTAINS 'Ciencia e Ingenier√≠a de Datos'
RETURN c.universidad AS universidad,
       c.nombre AS campus,
       e.nombre AS estudio,
       e.plazas AS plazas,
       e.nota_corte AS nota_corte
ORDER BY c.universidad;
\end{lstlisting}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: neo4j\_06\_campus\_gcid.png]}}
    \caption{Resultado de la consulta B1: campus que ofrecen el Grado en Ciencia e Ingenier√≠a de Datos.}
    \label{fig:neo4j_consulta_b1}
\end{figure}

\paragraph{B2. N√∫mero de estudios por universidad (GRADO vs M√ÅSTER)}

\begin{lstlisting}[style=cypher, caption={Consulta B2: Estad√≠sticas por universidad}]
MATCH (c:Campus)-[:OFRECE]->(e:Estudio)
WITH c.universidad AS universidad, e.tipo AS tipo, count(e) AS total
RETURN universidad,
       sum(CASE WHEN tipo = 'GRADO' THEN total ELSE 0 END) AS grados,
       sum(CASE WHEN tipo = 'MASTER' THEN total ELSE 0 END) AS masters,
       sum(total) AS total_estudios
ORDER BY universidad;
\end{lstlisting}

\paragraph{B5. Estaciones m√°s cercanas a cada campus}

\begin{lstlisting}[style=cypher, caption={Consulta B5: Accesibilidad de campus}]
MATCH (c:Campus)-[r:CERCANA]->(e:Estacion)
RETURN c.nombre AS campus,
       c.universidad AS universidad,
       collect({
           estacion: e.nombre,
           minutos: r.minutos,
           rol: r.rol
       }) AS estaciones_cercanas
ORDER BY c.universidad, c.nombre;
\end{lstlisting}

\subsubsection{C. Consultas de Rutas}

\paragraph{C1. Camino m√°s corto desde Sol hasta Ciudad Universitaria}

\textbf{Uso del algoritmo \texttt{shortestPath()}:}

\begin{lstlisting}[style=cypher, caption={Consulta C1: Ruta m√°s corta}]
MATCH (origen:Estacion {nombre: 'Sol'}),
      (destino:Estacion {nombre: 'Ciudad Universitaria'}),
      path = shortestPath((origen)-[:SIGUIENTE*]-(destino))
RETURN [n IN nodes(path) | n.nombre] AS ruta,
       length(path) AS num_estaciones;
\end{lstlisting}

\textbf{Resultado:}
\begin{verbatim}
ruta: ["Sol", "Tribunal", ..., "Moncloa", "Ciudad Universitaria"]
num_estaciones: 8
\end{verbatim}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: neo4j\_07\_ruta\_corta\_sol\_cu.png]}}
    \caption{Visualizaci√≥n del camino m√°s corto entre Sol y Ciudad Universitaria.}
    \label{fig:neo4j_consulta_c1}
\end{figure}

\paragraph{C2. Camino m√°s corto a campus espec√≠fico}

\begin{lstlisting}[style=cypher, caption={Consulta C2: Ruta a campus de Moncloa (UPM)}]
MATCH (origen:Estacion {nombre: 'Atocha'}),
      (campus:Campus {nombre: 'Campus de Moncloa (UPM)'})-[:CERCANA]->(destino:Estacion),
      path = shortestPath((origen)-[:SIGUIENTE*]-(destino))
RETURN campus.nombre AS campus,
       destino.nombre AS estacion_destino,
       [n IN nodes(path) | n.nombre] AS ruta,
       length(path) AS num_estaciones
ORDER BY num_estaciones
LIMIT 1;
\end{lstlisting}

\textbf{Interpretaci√≥n:} Encuentra la estaci√≥n cercana al campus que minimiza la distancia desde Atocha.

\paragraph{C3. Rutas a campus con M√°ster en IA}

\begin{lstlisting}[style=cypher, caption={Consulta C3: Rutas multiobjetivo (estudio + distancia)}]
MATCH (origen:Estacion {nombre: 'Sol'}),
      (campus:Campus)-[:OFRECE]->(estudio:Estudio),
      (campus)-[:CERCANA]->(destino:Estacion)
WHERE estudio.nombre CONTAINS 'Inteligencia Artificial' AND estudio.tipo = 'MASTER'
WITH origen, campus, destino, estudio
MATCH path = shortestPath((origen)-[:SIGUIENTE*]-(destino))
RETURN campus.universidad AS universidad,
       campus.nombre AS campus,
       destino.nombre AS estacion_destino,
       length(path) AS num_estaciones,
       [n IN nodes(path) | n.nombre] AS ruta
ORDER BY num_estaciones;
\end{lstlisting}

\textbf{Resultado:}
\begin{verbatim}
universidad  campus                num_estaciones  ruta
--------------------------------------------------------
UCM          Ciudad Universitaria  8               ["Sol", ..., "Ciudad Universitaria"]
UPM          Campus Sur            12              ["Sol", "Atocha", ..., "Miguel Hern√°ndez"]
UC3M         Campus de Legan√©s     -               (requiere l√≠nea 12, no modelada)
\end{verbatim}

\subsubsection{D. Cambios de L√≠nea y Comparativa Avanzada}

\paragraph{D1. Calcular cambios de l√≠nea en una ruta}

\textbf{Objetivo:} Contar cu√°ntas veces se cambia de l√≠nea en un trayecto.

\textbf{T√©cnica:} Usar la propiedad \texttt{lineaId} en las relaciones \texttt{:SIGUIENTE} para detectar cambios.

\begin{lstlisting}[style=cypher, caption={Consulta D1: C√°lculo de cambios de l√≠nea}]
MATCH (origen:Estacion {nombre: 'Pinar de Chamart√≠n'}),
      (destino:Estacion {nombre: 'Moncloa'}),
      path = shortestPath((origen)-[:SIGUIENTE*]-(destino))
WITH path,
     [r IN relationships(path) | r.lineaId] AS lineas_ruta
UNWIND range(0, size(lineas_ruta) - 2) AS i
WITH path, lineas_ruta,
     CASE WHEN lineas_ruta[i] <> lineas_ruta[i+1] THEN 1 ELSE 0 END AS cambio
RETURN [n IN nodes(path) | n.nombre] AS ruta,
       length(path) AS num_estaciones,
       sum(cambio) AS num_cambios_linea;
\end{lstlisting}

\textbf{Explicaci√≥n del algoritmo:}
\begin{enumerate}
    \item Se extrae un array con los \texttt{lineaId} de cada tramo del path
    \item Se itera por pares consecutivos $(i, i+1)$
    \item Si \texttt{lineaId[i] != lineaId[i+1]}, hay un cambio de l√≠nea
    \item Se suma el total de cambios
\end{enumerate}

\textbf{Resultado esperado:}
\begin{verbatim}
ruta: ["Pinar de Chamart√≠n", ..., "Tribunal", ..., "Moncloa"]
num_estaciones: 11
num_cambios_linea: 1  (cambio en Tribunal: L1 ‚Üí L10 ‚Üí L3)
\end{verbatim}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: neo4j\_08\_ruta\_con\_cambios.png]}}
    \caption{Resultado de la consulta D1 mostrando ruta con c√°lculo de cambios de l√≠nea.}
    \label{fig:neo4j_consulta_d1}
\end{figure}

\paragraph{D2. Comparar rutas por cambios de l√≠nea}

\textbf{Uso de \texttt{allShortestPaths()} para obtener m√∫ltiples rutas:}

\begin{lstlisting}[style=cypher, caption={Consulta D2: Comparar rutas alternativas}]
MATCH (origen:Estacion {nombre: 'Sol'}),
      (campus:Campus {nombre: 'Ciudad Universitaria (UCM)'})-[:CERCANA]->(destino:Estacion),
      path = allShortestPaths((origen)-[:SIGUIENTE*]-(destino))
WITH path,
     [r IN relationships(path) | r.lineaId] AS lineas_ruta,
     [n IN nodes(path) | n.nombre] AS nombres_ruta
UNWIND range(0, size(lineas_ruta) - 2) AS i
WITH path, lineas_ruta, nombres_ruta,
     CASE WHEN lineas_ruta[i] <> lineas_ruta[i+1] THEN 1 ELSE 0 END AS cambio
RETURN nombres_ruta AS ruta,
       length(path) AS num_estaciones,
       sum(cambio) AS num_cambios_linea
ORDER BY num_cambios_linea, num_estaciones
LIMIT 5;
\end{lstlisting}

\textbf{Resultado:}
\begin{verbatim}
ruta                                num_estaciones  num_cambios_linea
-------------------------------------------------------------------
["Sol", "Callao", ..., "Moncloa"]   7               0   (mejor: sin cambios)
["Sol", "Tribunal", ..., "Moncloa"] 8               1
\end{verbatim}

\paragraph{D3. Tiempo total de viaje estimado}

\begin{lstlisting}[style=cypher, caption={Consulta D3: Suma de tiempos de viaje}]
MATCH (origen:Estacion {nombre: 'Atocha'}),
      (destino:Estacion {nombre: 'Ciudad Universitaria'}),
      path = shortestPath((origen)-[:SIGUIENTE*]-(destino))
WITH path,
     [r IN relationships(path) | r.tiempo_viaje] AS tiempos
RETURN [n IN nodes(path) | n.nombre] AS ruta,
       length(path) AS num_estaciones,
       reduce(total = 0, tiempo IN tiempos | total + tiempo) AS tiempo_total_minutos;
\end{lstlisting}

\textbf{Resultado:}
\begin{verbatim}
tiempo_total_minutos: 23   (11 estaciones √ó ~2 min/estaci√≥n)
\end{verbatim}

\subsection{√çndices y Constraints}

Se crearon constraints de unicidad e √≠ndices para optimizar consultas:

\begin{lstlisting}[style=cypher, caption={Constraints de unicidad}]
CREATE CONSTRAINT linea_numero IF NOT EXISTS
    FOR (l:Linea) REQUIRE l.numero IS UNIQUE;

CREATE CONSTRAINT estacion_id IF NOT EXISTS
    FOR (e:Estacion) REQUIRE e.id IS UNIQUE;

CREATE CONSTRAINT campus_nombre IF NOT EXISTS
    FOR (c:Campus) REQUIRE c.nombre IS UNIQUE;
\end{lstlisting}

\begin{lstlisting}[style=cypher, caption={√çndices de b√∫squeda}]
CREATE INDEX estacion_nombre IF NOT EXISTS
    FOR (e:Estacion) ON (e.nombre);

CREATE INDEX campus_universidad IF NOT EXISTS
    FOR (c:Campus) ON (c.universidad);

CREATE INDEX estudio_nombre IF NOT EXISTS
    FOR (e:Estudio) ON (e.nombre);

CREATE INDEX estudio_tipo IF NOT EXISTS
    FOR (e:Estudio) ON (e.tipo);
\end{lstlisting}

% ============================================================================
% 4. PARTE C - FUNCIONALIDAD DE RECOMENDACI√ìN
% ============================================================================
\section{Parte C - Funcionalidad de Recomendaci√≥n Integrada}

\subsection{Objetivo}

Implementar una funcionalidad que, dada una estaci√≥n de origen y un estudio de GRADO, recomiende el mejor campus considerando:
\begin{itemize}
    \item Accesibilidad en Metro (distancia en estaciones)
    \item N√∫mero de cambios de l√≠nea
    \item Proximidad de la estaci√≥n al campus (minutos andando)
\end{itemize}

\subsection{Implementaci√≥n en MongoDB (Versi√≥n Simplificada)}

\textbf{Limitaci√≥n:} MongoDB solo puede calcular distancias si el origen y el destino est√°n en la \textbf{misma l√≠nea} usando el campo \texttt{indice\_por\_linea}.

\begin{lstlisting}[style=python, caption={Recomendaci√≥n simplificada en MongoDB (solo misma l√≠nea)}]
def recomendar_campus_simplificado(self, nombre_estacion_origen,
                                    nombre_estudio, tipo_estudio="GRADO"):
    # 1. Obtener l√≠neas disponibles desde origen
    estacion_origen = self.db.estaciones.find_one({"nombre": nombre_estacion_origen})
    lineas_origen = estacion_origen.get("lineas", [])

    # 2. Buscar campus que ofrecen el estudio
    campus_con_estudio = list(self.db.campus.find({
        "estudios": {
            "$elemMatch": {
                "tipo": tipo_estudio,
                "nombre": {"$regex": nombre_estudio, "$options": "i"}
            }
        }
    }))

    resultados = []

    # 3. Para cada campus, verificar si hay l√≠nea en com√∫n
    for campus in campus_con_estudio:
        campus_info = {
            "universidad": campus["universidad"],
            "nombre_campus": campus["nombre"],
            "accesible_misma_linea": False,
            "mejor_ruta": None
        }

        for est_cercana in campus["estaciones_cercanas"]:
            estacion_campus = self.db.estaciones.find_one(
                {"_id": est_cercana["estacion_id"]}
            )

            # Verificar l√≠neas en com√∫n
            lineas_comunes = set(lineas_origen) & set(estacion_campus["lineas"])

            if lineas_comunes:
                # HAY L√çNEA EN COM√öN - Calcular distancia
                linea_comun = list(lineas_comunes)[0]

                indice_origen = estacion_origen["indice_por_linea"][str(linea_comun)]
                indice_destino = estacion_campus["indice_por_linea"][str(linea_comun)]

                distancia = abs(indice_destino - indice_origen)
                tiempo_total = (distancia * 2.5) + est_cercana["minutos_andando"]

                campus_info["accesible_misma_linea"] = True
                campus_info["mejor_ruta"] = {
                    "estacion": estacion_campus["nombre"],
                    "linea": linea_comun,
                    "distancia_estaciones": distancia,
                    "tiempo_total_estimado": tiempo_total
                }

        resultados.append(campus_info)

    # 4. Ordenar: primero accesibles, luego por tiempo
    resultados.sort(
        key=lambda x: (
            not x["accesible_misma_linea"],
            x["mejor_ruta"]["tiempo_total_estimado"] if x["mejor_ruta"] else 9999
        )
    )

    # 5. Mostrar resultados
    for i, campus in enumerate(resultados, 1):
        print(f"\n{i}. {campus['nombre_campus']} ({campus['universidad']})")

        if campus["accesible_misma_linea"]:
            ruta = campus["mejor_ruta"]
            print(f"   ‚úÖ ACCESIBLE en MISMA L√çNEA (L{ruta['linea']})")
            print(f"   ‚è±Ô∏è  TIEMPO TOTAL: {ruta['tiempo_total_estimado']:.1f} min")
        else:
            print(f"   ‚ö†Ô∏è  REQUIERE CAMBIO DE L√çNEA")
            print(f"   üí° Usar Neo4j para calcular ruta completa")

    return resultados
\end{lstlisting}

\textbf{Ejemplo de ejecuci√≥n desde Sol:}

\begin{verbatim}
>>> recomendar_campus_simplificado("Sol", "Ciencia e Ingenier√≠a de Datos", "GRADO")

1. Ciudad Universitaria (UCM)
   ‚úÖ ACCESIBLE en MISMA L√çNEA (L3)
   ‚è±Ô∏è  TIEMPO TOTAL: 22.5 min   (7 est √ó 2.5 min + 5 min andando)

2. Campus de Legan√©s (UC3M)
   ‚ö†Ô∏è  REQUIERE CAMBIO DE L√çNEA
   üí° Usar Neo4j para calcular ruta completa

3. Campus de Fuenlabrada (URJC)
   ‚ö†Ô∏è  REQUIERE CAMBIO DE L√çNEA
   üí° Usar Neo4j para calcular ruta completa
\end{verbatim}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: mongodb\_10\_recomendacion\_simplificada.png]}}
    \caption{Salida de la funcionalidad de recomendaci√≥n simplificada en MongoDB, mostrando limitaci√≥n para rutas con cambios.}
    \label{fig:mongodb_recomendacion}
\end{figure}

\subsection{Implementaci√≥n en Neo4j (Versi√≥n Completa)}

Neo4j puede calcular rutas con cualquier n√∫mero de cambios de l√≠nea usando \texttt{shortestPath()}.

\begin{lstlisting}[style=cypher, caption={Recomendaci√≥n completa en Neo4j (con cambios de l√≠nea)}]
MATCH (origen:Estacion {nombre: 'Sol'}),
      (campus:Campus)-[:OFRECE]->(estudio:Estudio),
      (campus)-[:CERCANA]->(destino:Estacion)
WHERE estudio.tipo = 'GRADO' AND
      estudio.nombre CONTAINS 'Ciencia e Ingenier√≠a de Datos'
WITH origen, campus, estudio, destino
MATCH path = shortestPath((origen)-[:SIGUIENTE*]-(destino))
WITH campus, estudio, destino, path,
     [r IN relationships(path) | r.lineaId] AS lineas_ruta
UNWIND range(0, size(lineas_ruta) - 2) AS i
WITH campus, estudio, destino, path, lineas_ruta,
     CASE WHEN lineas_ruta[i] <> lineas_ruta[i+1] THEN 1 ELSE 0 END AS cambio
RETURN campus.universidad AS universidad,
       campus.nombre AS campus_nombre,
       estudio.plazas AS plazas,
       estudio.nota_corte AS nota_corte,
       destino.nombre AS estacion_destino,
       length(path) AS num_estaciones,
       sum(cambio) AS num_cambios_linea
ORDER BY num_cambios_linea, num_estaciones;
\end{lstlisting}

\textbf{Resultado (ordenado por mejor ruta):}

\begin{table}[H]
\centering
\small
\begin{tabular}{@{}llrrrr@{}}
\toprule
\textbf{Universidad} & \textbf{Campus} & \textbf{Plazas} & \textbf{Nota} & \textbf{Est.} & \textbf{Cambios} \\ \midrule
UCM & Ciudad Universitaria & 60 & 12.5 & 7 & 0 \\
UC3M & Campus de Legan√©s & 70 & 12.8 & 15 & 2 \\
URJC & Campus de Fuenlabrada & 65 & 12.2 & 18 & 2 \\ \bottomrule
\end{tabular}
\caption{Resultados de la recomendaci√≥n completa en Neo4j desde Sol.}
\label{tab:recomendacion_neo4j}
\end{table}

\textbf{Interpretaci√≥n:}
\begin{itemize}
    \item \textbf{Mejor opci√≥n: UCM - Ciudad Universitaria} (sin cambios, menor distancia)
    \item UC3M y URJC requieren 2 cambios de l√≠nea (penalizaci√≥n en tiempo y comodidad)
\end{itemize}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: neo4j\_09\_recomendacion\_completa.png]}}
    \caption{Resultado de la consulta de recomendaci√≥n completa en Neo4j, ordenada por n√∫mero de cambios y distancia.}
    \label{fig:neo4j_recomendacion}
\end{figure}

\subsection{Comparaci√≥n Razonada: MongoDB vs Neo4j}

\begin{table}[H]
\centering
\begin{tabular}{@{}p{0.25\textwidth}p{0.35\textwidth}p{0.35\textwidth}@{}}
\toprule
\textbf{Criterio} & \textbf{MongoDB} & \textbf{Neo4j} \\ \midrule

\textbf{C√°lculo de rutas} &
Solo rutas directas (misma l√≠nea) usando \texttt{indice\_por\_linea}. Requiere l√≥gica externa para cambios. &
Nativo con \texttt{shortestPath()} para rutas con cualquier n√∫mero de cambios. \\ \midrule

\textbf{Cambios de l√≠nea} &
No puede calcularlos sin algoritmo externo complejo. &
Cuenta cambios usando propiedad \texttt{lineaId} en \texttt{:SIGUIENTE}. \\ \midrule

\textbf{Tiempo de desarrollo} &
Consulta simple, pero funcionalidad limitada. &
Consulta m√°s compleja (Cypher), pero soluci√≥n completa. \\ \midrule

\textbf{Rendimiento} &
R√°pido para filtrar campus por caracter√≠sticas (universidad, plazas, nota). &
Optimizado para traversal de grafos, eficiente en rutas. \\ \midrule

\textbf{Mantenibilidad} &
Requiere actualizar l√≥gica si cambia topolog√≠a de la red. &
Cambios en topolog√≠a se reflejan autom√°ticamente. \\ \midrule

\textbf{Caso de uso ideal} &
B√∫squedas y filtros sobre atributos de campus y estudios. &
Recomendaciones basadas en topolog√≠a y rutas √≥ptimas. \\ \bottomrule
\end{tabular}
\caption{Comparativa detallada MongoDB vs Neo4j para el problema de recomendaci√≥n.}
\label{tab:comparativa_final}
\end{table}

\subsection{Conclusi√≥n de la Parte C}

\textbf{MongoDB es superior para:}
\begin{itemize}
    \item Consultas de "¬øqu√© campus ofrecen el Grado X?"
    \item Filtros por atributos: universidad, tipo de estudio, plazas, nota de corte
    \item Obtener informaci√≥n completa de un campus (estudios embebidos)
\end{itemize}

\textbf{Neo4j es superior para:}
\begin{itemize}
    \item Calcular rutas √≥ptimas en la red de metro
    \item Contar cambios de l√≠nea y estimar tiempos totales
    \item Identificar hubs (estaciones con m√°s conexiones)
    \item Recomendaciones multiobjetivo (distancia + cambios + accesibilidad)
\end{itemize}

\textbf{Arquitectura h√≠brida recomendada:}
\begin{enumerate}
    \item Usar \textbf{Neo4j} para calcular las mejores rutas desde el origen a todos los campus candidatos
    \item Usar \textbf{MongoDB} para enriquecer los resultados con detalles de estudios, plazas y notas de corte
    \item Combinar ambos resultados en la capa de aplicaci√≥n para presentar al usuario
\end{enumerate}

% INSERTAR FIGURA
\begin{figure}[H]
    \centering
    \fbox{\textit{[INSERTAR CAPTURA: comparativa\_mongodb\_vs\_neo4j.png]}}
    \caption{Comparativa visual lado a lado: MongoDB (limitado) vs Neo4j (completo) para recomendaci√≥n.}
    \label{fig:comparativa_visual}
\end{figure}

% ============================================================================
% 5. PRUEBAS Y EJEMPLOS DE USO
% ============================================================================
\section{Pruebas y Ejemplos de Uso}

\subsection{Escenario 1: Estudiante desde Atocha busca M√°ster en IA}

\subsubsection{En MongoDB}

\begin{verbatim}
>>> recomendar_campus_simplificado("Atocha", "Inteligencia Artificial", "MASTER")

1. Ciudad Universitaria (UCM)
   ‚ö†Ô∏è  REQUIERE CAMBIO DE L√çNEA
   üí° Usar Neo4j para calcular ruta completa

2. Campus Sur (UPM)
   ‚úÖ ACCESIBLE en MISMA L√çNEA (L1)
   ‚è±Ô∏è  TIEMPO TOTAL: 27.5 min
\end{verbatim}

\subsubsection{En Neo4j}

\begin{lstlisting}[style=cypher]
MATCH (origen:Estacion {nombre: 'Atocha'}),
      (campus:Campus)-[:OFRECE]->(estudio:Estudio),
      (campus)-[:CERCANA]->(destino:Estacion)
WHERE estudio.tipo = 'MASTER' AND estudio.nombre CONTAINS 'Inteligencia Artificial'
WITH origen, campus, destino
MATCH path = shortestPath((origen)-[:SIGUIENTE*]-(destino))
RETURN campus.nombre, destino.nombre, length(path) AS distancia
ORDER BY distancia;
\end{lstlisting}

\textbf{Resultado:}
\begin{verbatim}
campus.nombre              destino.nombre          distancia
------------------------------------------------------------
Campus Sur (UPM)           Miguel Hern√°ndez        3
Ciudad Universitaria (UCM) Ciudad Universitaria    10
\end{verbatim}

\textbf{Conclusi√≥n:} Campus Sur (UPM) es la mejor opci√≥n (misma l√≠nea, distancia corta).

\subsection{Escenario 2: An√°lisis de hubs universitarios}

\subsubsection{Consulta en Neo4j}

\begin{lstlisting}[style=cypher]
MATCH (e:Estacion)<-[:CERCANA]-(c:Campus)
WITH e, collect(DISTINCT c.universidad) AS universidades, count(DISTINCT c) AS num_campus
WHERE num_campus > 1
RETURN e.nombre AS estacion,
       num_campus,
       universidades
ORDER BY num_campus DESC;
\end{lstlisting}

\textbf{Resultado:}
\begin{verbatim}
estacion               num_campus  universidades
------------------------------------------------
Ciudad Universitaria   2           ["UCM", "UPM"]
Moncloa                2           ["UCM", "UPM"]
\end{verbatim}

\textbf{Interpretaci√≥n:} La zona de Moncloa-Ciudad Universitaria es un hub que concentra oferta de UCM y UPM.

% ============================================================================
% 6. PLANIFICACI√ìN Y ESFUERZO DEL GRUPO
% ============================================================================
\section{Planificaci√≥n y Esfuerzo del Grupo}

\subsection{Distribuci√≥n de Tareas}

\begin{table}[H]
\centering
\small
\begin{tabular}{@{}llcc@{}}
\toprule
\textbf{Tarea} & \textbf{Responsable} & \textbf{Horas} & \textbf{Estado} \\ \midrule
Dise√±o modelo MongoDB & Miguel Alcocer & 4 & Completado \\
Dise√±o modelo Neo4j & √Ålvaro Mor√°n & 4 & Completado \\
Carga datos MongoDB & Miguel Alcocer & 3 & Completado \\
Carga datos Neo4j & √Ålvaro Mor√°n & 3 & Completado \\
Consultas MongoDB & Miguel Alcocer & 4 & Completado \\
Consultas Neo4j & √Ålvaro Mor√°n & 4 & Completado \\
Operaciones CRUD & √Ålvaro Mor√°n & 5 & Completado \\
Parte C (Recomendaci√≥n) & Miguel Alcocer & 6 & Completado \\
Visualizaciones & Miguel Alcocer & 2 & Completado \\
Memoria y documentaci√≥n & Ambos & 8 & Completado \\ \midrule
\textbf{Total} & & \textbf{43} & \\
\bottomrule
\end{tabular}
\caption{Distribuci√≥n de tareas y esfuerzo estimado}
\label{tab:planificacion}
\end{table}

\subsection{Cronolog√≠a}

\begin{itemize}[itemsep=0.3em]
    \item \textbf{Semana 1 (21-27 Dic)}: Dise√±o de modelos y carga inicial de datos
    \item \textbf{Semana 2 (28 Dic-3 Ene)}: Implementaci√≥n de consultas y operaciones CRUD
    \item \textbf{Semana 3 (4-8 Ene)}: Parte C, visualizaciones y memoria
\end{itemize}

% ============================================================================
% 7. CONCLUSIONES
% ============================================================================
\section{Conclusiones}

\subsection{Aprendizajes Clave}

\begin{enumerate}
    \item \textbf{Modelado documental vs grafo:} Se ha comprobado emp√≠ricamente que la elecci√≥n del modelo de datos debe estar guiada por los patrones de consulta dominantes. MongoDB es excelente para datos jer√°rquicos y consultas por atributos, mientras que Neo4j brilla en consultas de rutas y relaciones complejas.

    \item \textbf{Embebido vs Referencias:} La decisi√≥n de embeber estudios en campus (MongoDB) vs modelarlos como nodos independientes (Neo4j) demuestra c√≥mo un mismo dominio puede modelarse de formas radicalmente distintas seg√∫n la tecnolog√≠a.

    \item \textbf{Importancia de √≠ndices:} Tanto en MongoDB como en Neo4j, los √≠ndices mejoran dr√°sticamente el rendimiento de consultas frecuentes. La creaci√≥n estrat√©gica de √≠ndices es fundamental.

    \item \textbf{Limitaciones de cada paradigma:}
    \begin{itemize}
        \item MongoDB no puede calcular rutas con m√∫ltiples saltos sin l√≥gica externa compleja
        \item Neo4j requiere m√°s trabajo para consultas de agregaci√≥n sobre atributos (comparado con pipelines de MongoDB)
    \end{itemize}

    \item \textbf{Complementariedad:} En un sistema real de producci√≥n, la arquitectura ideal combinar√≠a ambas tecnolog√≠as:
    \begin{itemize}
        \item Neo4j como "motor de rutas" (c√°lculo de trayectos √≥ptimos)
        \item MongoDB como "repositorio de datos" (informaci√≥n detallada de campus, estudios, horarios, etc.)
    \end{itemize}
\end{enumerate}

\subsection{Casos de Uso Reales}

Este proyecto demuestra aplicabilidad directa en:

\begin{itemize}
    \item \textbf{Planificadores de viaje:} Apps como Google Maps combinan grafos (rutas) con bases de datos documentales (detalles de lugares)
    \item \textbf{Sistemas de recomendaci√≥n educativa:} Plataformas como \textit{Universia} o \textit{Educaweb} que ayudan a elegir universidad considerando m√∫ltiples criterios
    \item \textbf{An√°lisis de movilidad urbana:} Estudios de planificaci√≥n que identifican zonas mal conectadas o saturadas
\end{itemize}

\subsection{Posibles Extensiones}

Funcionalidades que podr√≠an implementarse en el futuro:

\begin{enumerate}
    \item \textbf{√çndices geoespaciales en MongoDB:} Usar \texttt{2dsphere} para consultas tipo "campus a menos de 2km de una coordenada"

    \item \textbf{Algoritmos de centralidad en Neo4j:} Usar \texttt{PageRank} o \texttt{Betweenness Centrality} para identificar estaciones clave

    \item \textbf{Integraci√≥n con datos reales:} Consumir API de Metro de Madrid para actualizar tiempos de viaje en tiempo real

    \item \textbf{Interfaz web:} Crear un frontend React que consuma endpoints que combinan MongoDB y Neo4j

    \item \textbf{Criterios adicionales:} Considerar precio del billete seg√∫n zonas, accesibilidad (ascensores), horarios nocturnos
\end{enumerate}

% ============================================================================
% AP√âNDICE - C√ìDIGO FUENTE
% ============================================================================
\section*{Ap√©ndice A: C√≥digo Fuente Principal}
\addcontentsline{toc}{section}{Ap√©ndice A: C√≥digo Fuente Principal}

\subsection*{A.1 Carga de datos en MongoDB}

\begin{lstlisting}[style=python, caption={Fragmento de load\_data.py (MongoDB)}]
def load_lineas(self, lineas_data: List[Dict]) -> Dict[int, ObjectId]:
    """Carga las l√≠neas de metro en MongoDB"""
    lineas_collection = self.db.lineas
    linea_id_map = {}

    for linea in lineas_data:
        result = lineas_collection.insert_one(linea)
        linea_id_map[linea["numero"]] = result.inserted_id

    return linea_id_map

def _update_lineas_with_estaciones(self, linea_id_map, estacion_id_map, estaciones_data):
    """Actualiza las l√≠neas con sus estaciones ordenadas"""
    lineas_collection = self.db.lineas

    # Agrupar estaciones por l√≠nea
    lineas_estaciones = {}
    for estacion_orig in estaciones_data:
        original_id = f"est_l{estacion_orig['lineas'][0]}_{...}"

        for linea_num in estacion_orig["lineas"]:
            if linea_num not in lineas_estaciones:
                lineas_estaciones[linea_num] = []

            orden = estacion_orig["indice_por_linea"].get(str(linea_num), 0)
            lineas_estaciones[linea_num].append({
                "estacion_id": estacion_id_map.get(original_id),
                "orden": orden
            })

    # Actualizar cada l√≠nea con sus estaciones ordenadas
    for linea_num, estaciones in lineas_estaciones.items():
        estaciones_ordenadas = sorted(estaciones, key=lambda x: x["orden"])
        estaciones_ids = [est["estacion_id"] for est in estaciones_ordenadas]

        lineas_collection.update_one(
            {"_id": linea_id_map[linea_num]},
            {"$set": {"estaciones_ids": estaciones_ids}}
        )
\end{lstlisting}

\subsection*{A.2 Carga de datos en Neo4j}

\begin{lstlisting}[style=cypher, caption={Fragmento de load\_data.py (Neo4j) - Creaci√≥n de relaciones SIGUIENTE}]
# Preparar relaciones SIGUIENTE entre estaciones consecutivas
relaciones_siguiente = []
for linea_num, estaciones in estaciones_por_linea.items():
    estaciones_ordenadas = sorted(estaciones, key=lambda x: x["orden"])

    for i in range(len(estaciones_ordenadas) - 1):
        est_actual = estaciones_ordenadas[i]
        est_siguiente = estaciones_ordenadas[i + 1]

        tiempo_viaje = 2 + (i % 2)  # Alterna entre 2 y 3 minutos

        relaciones_siguiente.append({
            "desde": est_actual["id"],
            "hasta": est_siguiente["id"],
            "linea_id": linea_num,
            "tiempo_viaje": tiempo_viaje
        })

# Ejecutar creaci√≥n masiva con UNWIND
query = """
UNWIND $relaciones AS rel
MATCH (e1:Estacion {id: rel.desde})
MATCH (e2:Estacion {id: rel.hasta})
CREATE (e1)-[:SIGUIENTE {lineaId: rel.linea_id, tiempo_viaje: rel.tiempo_viaje}]->(e2)
"""
session.run(query, relaciones=relaciones_siguiente)
\end{lstlisting}

\subsection*{A.3 Consulta de recomendaci√≥n en Neo4j (Parte C)}

\begin{lstlisting}[style=cypher, caption={Consulta completa de recomendaci√≥n multiobjetivo}]
-- F1. Recomendaci√≥n completa con cambios de l√≠nea
MATCH (origen:Estacion {nombre: 'Sol'}),
      (campus:Campus)-[:OFRECE]->(estudio:Estudio),
      (campus)-[:CERCANA]->(destino:Estacion)
WHERE estudio.tipo = 'GRADO' AND
      estudio.nombre CONTAINS 'Ciencia e Ingenier√≠a de Datos'
WITH origen, campus, estudio, destino
MATCH path = shortestPath((origen)-[:SIGUIENTE*]-(destino))
WITH campus, estudio, destino, path,
     [r IN relationships(path) | r.lineaId] AS lineas_ruta
UNWIND range(0, size(lineas_ruta) - 2) AS i
WITH campus, estudio, destino, path, lineas_ruta,
     CASE WHEN lineas_ruta[i] <> lineas_ruta[i+1] THEN 1 ELSE 0 END AS cambio
RETURN campus.universidad AS universidad,
       campus.nombre AS campus,
       estudio.plazas AS plazas,
       estudio.nota_corte AS nota_corte,
       destino.nombre AS estacion_destino,
       length(path) AS num_estaciones,
       sum(cambio) AS num_cambios_linea,
       [n IN nodes(path) | n.nombre] AS ruta
ORDER BY num_cambios_linea, num_estaciones;
\end{lstlisting}

% ============================================================================
% REFERENCIAS
% ============================================================================
\begin{thebibliography}{9}

\bibitem{mongodb_docs}
MongoDB Documentation,
\textit{MongoDB Manual},
\url{https://docs.mongodb.com/},
2025.

\bibitem{neo4j_docs}
Neo4j, Inc.,
\textit{Neo4j Documentation},
\url{https://neo4j.com/docs/},
2025.

\bibitem{metro_madrid}
Metro de Madrid,
\textit{Plano oficial del Metro de Madrid},
\url{https://www.metromadrid.es/es/viaja-en-metro/plano-de-metro-de-madrid},
2025.

\bibitem{cypher_manual}
Neo4j, Inc.,
\textit{Cypher Query Language Reference},
\url{https://neo4j.com/docs/cypher-manual/current/},
2025.

\bibitem{aggregation_pipeline}
MongoDB, Inc.,
\textit{Aggregation Pipeline},
\url{https://docs.mongodb.com/manual/core/aggregation-pipeline/},
2025.

\end{thebibliography}

\end{document}
